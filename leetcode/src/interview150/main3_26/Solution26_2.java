package interview150.main3_26;

// eg {0,0,1,1,1,2,2,3,3,4}
// 0,1,2,1,1,2,2,3,3,4
public class Solution26_2 {
    // 原地删除重复数据，优秀题解：双指针之一（逻辑上没有快慢指针容易理解）
    public int removeDuplicates(int[] nums) {
        int cnt = 0; // 记录重复的数据的个数
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) {
                cnt++;
            } else {
                // 继上次连续之后，第一次遇到不同的数据
                // 把当前的数的第一个出现，向前面移动重复数据个数个位数

                // 关键点1.是直接向前移动并且覆盖之，原来位置还是该值不动
                // 关键点2.之所以由于当前位置值并不动，导致并不会影响后续对于cnt的计数

                // 疑问：为什么当前值向前移动cnt位，就一定恰好能到其正确的位置

                /*
                    原理就是，cnt一直维护着'重复'元素的数量，而除了重复元素之外的
                    就是有序唯一元素的区域，所以从第一个'唯一'元素开始，到后面任意一个
                    '唯一'元素，前退cnt位必然就是刚好是唯一元素区域的末尾
                 */
                nums[i - cnt] = nums[i];
            }
        }
        return nums.length - cnt;
    }
}
